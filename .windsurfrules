# Tyfo.dev Project Windsurf Rules
# Configuration complète pour l'assistant Windsurf AI
# Contexte: Monorepo pnpm, AdonisJS + TypeScript, Inertia + React

# =====================================================================
# INFORMATION GÉNÉRALE
# =====================================================================
project:
  name: Tyfo.dev
  description: Plateforme collaborative de gestion de fichiers avec gestion avancée des utilisateurs, rôles et cercles
  repository: https://github.com/tungdil213/tyfo.dev
  root: apps/tyfo.dev
  structure: monorepo
  packageManager: pnpm
  containerization: Docker
  language: TypeScript
  runtime: Node.js
  framework: AdonisJS

# =====================================================================
# ARCHITECTURE TECHNIQUE
# =====================================================================
architecture:
  backend: AdonisJS
  backendVersion: 6
  language: TypeScript
  tsconfig:
    strict: true
    noImplicitAny: true
    strictNullChecks: true
    noUnusedLocals: true
    noUnusedParameters: true
    noImplicitReturns: true
  frontend: React
  styling: TailwindCSS
  viewEngine: InertiaJS
  database: PostgreSQL
  orm: Lucid
  authentication: JWT
  testing: Jest
  apiVersion: v1
  apiBasePath: /api/v1
  # Exemple de modules DDD par domaine
  modules:
    iam: apps/tyfo.dev/app/Modules/IAM
    files: apps/tyfo.dev/app/Modules/Files
    circles: apps/tyfo.dev/app/Modules/Circles
    notifications: apps/tyfo.dev/app/Modules/Notifications

# =====================================================================
# RÉPERTOIRES IMPORTANTS
# =====================================================================
directories:
  app: apps/tyfo.dev/app
  config: apps/tyfo.dev/config
  tests:
    functional: apps/tyfo.dev/tests/functional
    unit: apps/tyfo.dev/tests/unit
    e2e: apps/tyfo.dev/tests/e2e
  docs: apps/tyfo.dev/docs/implementation
  contracts: apps/tyfo.dev/app/Contracts
  services: apps/tyfo.dev/app/Services
  repositories: apps/tyfo.dev/app/Repositories
  models: apps/tyfo.dev/app/Models
  migrations: apps/tyfo.dev/database/migrations
  seeds: apps/tyfo.dev/database/seeders
  commands: apps/tyfo.dev/commands
  ddd:
    domain: apps/tyfo.dev/app/Modules/**/Domain
    application: apps/tyfo.dev/app/Modules/**/Application
    infrastructure: apps/tyfo.dev/app/Modules/**/Infrastructure
    presentation: apps/tyfo.dev/app/Modules/**/Presentation

# =====================================================================
# COMMANDES PRINCIPALES
# =====================================================================
scripts:
  test: cd apps/tyfo.dev && pnpm run test
  lint: cd apps/tyfo.dev && pnpm run lint
  migrate: cd apps/tyfo.dev && node ace migration:run
  seed: cd apps/tyfo.dev && node ace db:seed
  reset: cd apps/tyfo.dev && node ace db:wipe && node ace migration:run && node ace db:seed
  dev: cd apps/tyfo.dev && node ace serve --watch

# =====================================================================
# ENTITÉS / MODÈLES (EXEMPLE)
# =====================================================================
entities:
  - name: User
    fields:
      - name: uuid
        type: string
        primary: true
      - name: fullName
        type: string
      - name: email
        type: string
        unique: true
      - name: password
        type: string
        protected: true
      - name: isArchived
        type: boolean
        default: false
    relations:
      - name: roles
        type: manyToMany
        entity: Role
        through: Attribution
      - name: circles
        type: manyToMany
        entity: Circle
        through: Attribution
      - name: files
        type: oneToMany
        entity: File

  - name: Role
    fields:
      - name: uuid
        type: string
        primary: true
      - name: name
        type: string
        unique: true
      - name: description
        type: string
        required: true
    relations:
      - name: users
        type: manyToMany
        entity: User
        through: Attribution

  - name: Circle
    fields:
      - name: uuid
        type: string
        primary: true
      - name: name
        type: string
      - name: description
        type: string
        required: true
      - name: user_id
        type: string
        required: true
      - name: isArchived
        type: boolean
        default: false
    relations:
      - name: users
        type: manyToMany
        entity: User
        through: Attribution
      - name: owner
        type: belongsTo
        entity: User

  - name: Attribution
    fields:
      - name: uuid
        type: string
        primary: true
      - name: user_id
        type: string
        required: true
      - name: role_id
        type: string
        required: true
      - name: circle_id
        type: string
        required: true
    relations:
      - name: user
        type: belongsTo
        entity: User
      - name: role
        type: belongsTo
        entity: Role
      - name: circle
        type: belongsTo
        entity: Circle

  - name: File
    fields:
      - name: uuid
        type: string
        primary: true
      - name: name
        type: string
      - name: path
        type: string
      - name: user_id
        type: string
      - name: isArchived
        type: boolean
        default: false
      - name: metadata
        type: json
    relations:
      - name: user
        type: belongsTo
        entity: User
      - name: versions
        type: oneToMany
        entity: Version

  - name: Version
    fields:
      - name: uuid
        type: string
        primary: true
      - name: file_id
        type: string
      - name: version_number
        type: integer
      - name: content_hash
        type: string
      - name: created_at
        type: datetime
    relations:
      - name: file
        type: belongsTo
        entity: File

  - name: Notification
    fields:
      - name: uuid
        type: string
        primary: true
      - name: user_id
        type: string
      - name: title
        type: string
      - name: message
        type: string
      - name: type
        type: string
      - name: read
        type: boolean
        default: false
      - name: created_at
        type: datetime
    relations:
      - name: user
        type: belongsTo
        entity: User

  - name: EventLog
    fields:
      - name: uuid
        type: string
        primary: true
      - name: user_id
        type: string
      - name: action
        type: string
      - name: entity_type
        type: string
      - name: entity_id
        type: string
      - name: metadata
        type: json
      - name: created_at
        type: datetime
    relations:
      - name: user
        type: belongsTo
        entity: User

# =====================================================================
# TESTS
# =====================================================================
testing:
  approach: TDD
  resetDbBeforeEach: true
  useFactories: true
  assertionsPerTest: 1
  preferSupertest: true
  testScenarios:
    - user-creation-flow
    - file-upload-and-versioning
    - role-assignment
    - circle-management
    - full-permission-check

# =====================================================================
# CONVENTIONS DE CODAGE
# =====================================================================
conventions:
  userNameField: fullName
  requireDescriptions:
    - Role
    - Circle
  dateFormat: YYYY-MM-DDTHH:mm:ssZ
  idField: uuid
  defaultPagination: 25
  softDelete: true
  archivableEntities:
    - User
    - Circle
    - File
  fileUploadDirectory: tmp/uploads
  fileStoragePath: storage/app/uploads

# =====================================================================
# PERMISSIONS & SÉCURITÉ
# =====================================================================
permissions:
  roles:
    - admin
    - editor
    - viewer
  defaultRole: viewer
  roleHierarchy:
    - admin
    - editor
    - viewer
  roleAssignment: true
  security:
    auditLog: true
    requireAuth: true
    passwordPolicy:
      minLength: 8
      requireNumber: true
      requireSpecial: true

# =====================================================================
# API
# =====================================================================
api:
  auth:
    strategy: jwt
    loginEndpoint: /api/v1/auth/login
    registerEndpoint: /api/v1/auth/register
  endpoints:
    users: /api/v1/users
    roles: /api/v1/roles
    circles: /api/v1/circles
    files: /api/v1/files
    notifications: /api/v1/notifications
  paginationParam: page
  perPageParam: perPage

# =====================================================================
# COMMANDES CLI
# =====================================================================
cli:
  userCommands:
    - create-user
    - delete-user
    - list-users
    - assign-role
  fileCommands:
    - upload-file
    - list-files
    - delete-file
    - file-history
    - restore-file
  circleCommands:
    - create-circle
    - archive-circle
    - add-user-circle
    - remove-user-circle
    - list-circles

# =====================================================================
# INTÉGRATION CONTINUE
# =====================================================================
ci:
  enabled: true
  provider: GitHub Actions
  testCommand: pnpm run test
  lintCommand: pnpm run lint
  branches:
    main: production
    develop: staging
  triggers:
    - push
    - pullRequest
  notifications:
    success: false
    failure: true

# =====================================================================
# CONFIGURATION WINDSURF / RÈGLES D'ARCHI & QUALITÉ
# =====================================================================
windsurf:
  preferredApproach: TDD
  testFirst: true
  verboseComments: true
  prioritizeUserRequirements: true
  checkForLintErrors: true
  alwaysIncludeTests: true
  suggestDocumentation: true
  apisFirst: true
  uiLast: true
  assistWith:
    - testing
    - api
    - database
    - authentication
    - fileFunctionality
    - userManagement
    - roleManagement
    - circleManagement
    - documentation
  ignoredPatterns:
    - node_modules
    - .git
    - tmp
    - build
    - dist
  maxContextFiles: 50
  maxSearchDepth: 5
  enforceResultPattern: true

  rules:
    - name: "Use Result<T> pattern everywhere"
      description: |
        Toute fonction métier dans les couches Domain, Application ou Infrastructure
        (services, use cases, repositories) doit retourner un objet Result<T>
        (succès ou échec explicite) et non pas une valeur brute ni un throw.
        Les exceptions métier doivent être encapsulées dans Result<T>.
      checks:
        - Vérifier que chaque méthode publique dans les couches Application/Services/Repositories retourne Result<T>.
        - Refuser les `throw` en dehors des BusinessException dans les couches métier.
        - S'assurer que chaque appelant gère Result avec `if (result.isFailure)` avant d'accéder à `result.value`.
        - Vérifier que les contrôleurs Adonis utilisent le pattern : 
          `if (result.isFailure) { throw new BusinessException(...) }`.
        - Interdire l'accès direct à `result.value` sans vérification préalable de `result.isSuccess`.
      autofix: |
        Transformer les valeurs brutes de retour en Result.ok().
        Encapsuler les exceptions métier dans Result.fail().
        Corriger "Result.err()" vers "Result.fail()".
        Ajouter les types Result<T> et les vérifications isFailure/isSuccess manquantes.

    - name: "BusinessException pattern enforcement"
      description: |
        Toutes les exceptions métier doivent hériter de BusinessException.
        Intégration avec HttpExceptionHandler et (optionnellement) Sentry.
      checks:
        - Vérifier que les exceptions métier héritent de BusinessException.
        - Vérifier classification, severity, userMessage, toastType, context.
        - Interdire les `throw new Error()` dans Domain/Application/Infrastructure.
        - S'assurer que les exceptions SECURITY n'exposent jamais d'infos sensibles.
        - Vérifier l'intégration dans HttpExceptionHandler.
      autofix: |
        Remplacer `throw new Error()` par une exception métier dédiée.
        Ajouter les champs manquants (userMessage, classification, severity, toastType).

    - name: "Toast integration with Sonner"
      description: |
        Feedback utilisateur systématique via Sonner côté front (Inertia + React).
      checks:
        - HttpExceptionHandler → flash messages pour BusinessException.
        - Contrôleurs → `session.flash('success', ...)` pour les succès importants.
        - ToastHandler présent dans le layout principal.
        - Types de toast cohérents avec userMessage / classification.
      autofix: |
        Ajouter des flash success après opérations critiques.
        Ajouter ToastHandler dans le layout si absent.

    - name: "Domain Driven Design architecture"
      description: |
        Séparation claire Domain / Application / Infrastructure / Presentation.
      checks:
        - Domain n'importe aucune dépendance externe (Adonis, Lucid, HTTP...).
        - Application n'accède pas directement aux modèles Lucid (passe par des ports/repositories).
        - Use cases injectent leurs dépendances (via constructeur/provider).
        - Repositories implémentent des interfaces (Contracts).
        - Contrôleurs Adonis ne contiennent pas de logique métier.
      autofix: |
        Déplacer la logique métier des contrôleurs vers des use cases.
        Créer des interfaces de repository manquantes.
        Mettre en place l'injection de dépendances via constructeur.

    - name: "Security-first error handling"
      description: |
        Gestion sécurisée des erreurs pour éviter l'exposition d'informations sensibles.
      checks:
        - Messages d'erreur d'authentification génériques.
        - Erreurs de validation sans structure interne sensible.
        - Stack traces non exposées en prod.
        - Erreurs DB encapsulées dans BusinessException ou Result.fail().
      autofix: |
        Remplacer les messages sensibles par des messages génériques.
        Classifier les erreurs de sécurité (SECURITY) et adapter userMessage/logs.

    - name: "Service Testing Strategy"
      description: |
        Tests focalisés sur la logique métier (use cases/services), avec mocks pour les dépendances externes.
      checks:
        - Chaque use case a au moins un test unitaire.
        - Tests utilisent DTOs plutôt que Domain Entities brutes.
        - Repositories mockés dans les tests des use cases.
        - Couverture des cas succès + échec (Result.ok / Result.fail).
      autofix: |
        Générer des fichiers de test pour les nouveaux use cases.
        Ajouter des mocks basiques pour les repositories utilisés.

    - name: "DTO and Serialization Pattern"
      description: |
        DTOs pour découpler Domain/Lucid des APIs & use cases, avec serializers dédiés.
      checks:
        - DTOs regroupés (ex: app/DTOs ou Modules/**/Application/DTOs/).
        - Suffixe `Dto` pour les DTOs, `Serializer` pour les serializers.
        - DTOs sans logique métier.
      autofix: |
        Générer automatiquement DTOs et serializers de base.
        Refactorer les use cases pour passer par DTOs.

    - name: "Factory and Test Data Strategy"
      description: |
        Factories de test pour générer des données cohérentes et réutilisables.
      checks:
        - Une factory pour chaque entité importante dans `tests/factories/`.
        - Factories produisent des DTOs ou modèles de test.
        - Données réalistes mais anonymisées.
      autofix: |
        Générer des factories pour chaque entité manquante.
        Refactorer les tests existants pour utiliser les factories.

    - name: "Comprehensive Test Architecture"
      description: |
        Tests unitaires, intégration, e2e bien séparés avec responsabilités claires.
      checks:
        - Structure: tests/unit, tests/integration, tests/e2e, tests/factories.
        - Use cases → tests unitaires avec mocks.
        - Services techniques → tests d'intégration ciblés.
      autofix: |
        Créer la structure de dossiers manquante.
        Générer des tests basiques pour les nouveaux use cases.

    - name: "Factory and Faker Strategy"
      description: |
        Fakers pour générer des données réalistes, typées, sans sinon (préférer jest.fn()).
      checks:
        - Aucun test n'utilise sinon.
        - Un faker par entité/DTO dans `tests/fakers/`.
      autofix: |
        Remplacer sinon par jest.fn().
        Générer BaseFaker + fakers dérivés.

    - name: "Hexagonal Architecture Enforcement"
      description: |
        Ports & Adapters: use cases ne dépendent que d'interfaces (ports).
      checks:
        - Use cases n'importent pas d'implémentations techniques concrètes.
        - Ports définis (ex: app/Ports ou Modules/**/Application/Ports).
        - Infrastructure implémente ces ports.
      autofix: |
        Générer des interfaces ports pour les dépendances externes.
        Déplacer la logique technique dans Infrastructure.

    - name: "Contract Testing Strategy"
      description: |
        Tests de contrat pour vérifier la compatibilité DTOs/serializers/API.
      checks:
        - Un test de contrat par endpoint critique (tests/contract/).
        - Schémas respectés (Zod/Joi ou OpenAPI).
      autofix: |
        Générer un test de contrat pour chaque nouvel endpoint.
        Ajouter un validateur de schéma JSON.

    - name: "Mutation Testing Strategy"
      description: |
        Tests de mutation (StrykerJS, par ex.) pour valider la robustesse de la base de tests.
      checks:
        - Pipeline CI exécute les mutation tests au moins sur Application.
        - Seuil de mutation coverage > 80%.
      autofix: |
        Ajouter StrykerJS + config par défaut.

    - name: "Test Coverage Enforcement"
      description: |
        Couverture minimale de tests sur Application et Domain.
      checks:
        - Coverage global >= 80%.
        - Coverage Domain/Application >= 90%.
      autofix: |
        Ajouter la vérification du coverage dans la CI.
        Générer un rapport coverage HTML.

    - name: "Dependency Injection Enforcement"
      description: |
        Utiliser l'IoC Adonis pour enregistrer les implémentations,
        mais injecter les dépendances dans les classes métier (pas de `ioc.use` partout).
      checks:
        - Pas de `new` direct de services/repositories dans les use cases/contrôleurs.
        - Dépendances résolues via injection (constructeur, providers) plutôt que `ioc.use` dans Domain/Application.
        - Adapters dans Infrastructure implémentent les contrats définis.
      autofix: |
        Déplacer les instanciations vers des providers/factories.
        Ajouter les interfaces manquantes dans Contracts/Ports.

    - name: "UI Library Consistency"
      description: |
        `packages/ui` = librairie UI réutilisable, découplée de la logique métier.
      checks:
        - `packages/ui` n'importe jamais `apps/`.
        - Chaque nouveau composant a une story `apps/docs` (Storybook).
        - Composants testés avec React Testing Library.
      autofix: |
        Créer une story minimale par composant.
        Ajouter des tests de rendu basiques.

    - name: "Storybook Documentation Enforcement"
      description: |
        Storybook = documentation vivante des composants UI.
      checks:
        - Chaque composant `packages/ui` a une story.
        - Stories couvrent les principaux états/variantes.
      autofix: |
        Générer une story minimale pour chaque nouveau composant.
        Lancer `pnpm storybook:build` en CI.

    - name: "Visual Regression Testing"
      description: |
        Tests de régression visuelle sur les composants UI (Chromatic/Playwright).
      checks:
        - CI exécute des tests visuels sur `apps/docs`.
        - PR échoue en cas de diff visuel non approuvé.
      autofix: |
        Ajouter l'outil de visuel regression (Chromatic/Playwright).
        Générer des snapshots pour les nouveaux composants.

    - name: "Domain Factory Rule"
      description: |
        Entités complexes créées via des factories métier (Domain Factories).
      checks:
        - Pas d'instanciation directe d'entités Domain dans les use cases.
        - Repositories utilisent des factories métier pour hydrater les entités.
      autofix: |
        Déplacer la logique de création d'entité vers Domain Factories.

    - name: "Test/Seed Factory Rule"
      description: |
        Factories de test/seed réservées aux tests et seeders, jamais au code applicatif.
      checks:
        - Factories de test/seed dans `tests/factories/` ou `database/factories/` uniquement.
        - Pas d'import de ces factories dans `app/`.
      autofix: |
        Déplacer les factories de test/seed hors de `app/`.
        Supprimer les imports interdits.