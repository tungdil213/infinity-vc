# Tyfo.dev Project Windsurf Rules
# Configuration complète pour l'assistant Windsurf AI

# Information générale sur le projet
project:
  name: Tyfo.dev
  description: Plateforme collaborative de gestion de fichiers avec gestion avancée des utilisateurs, rôles et cercles
  repository: https://github.com/tungdil213/tyfo.dev
  root: apps/tyfo.dev
  structure: monorepo
  packageManager: pnpm
  containerization: Docker

# Architecture technique
architecture:
  backend: AdonisJS
  frontend: React
  styling: TailwindCSS
  viewEngine: InertiaJS
  database: PostgreSQL
  authentication: JWT
  testing: Jest
  apiVersion: v1
  apiBasePath: /api/v1

# Répertoires importants
directories:
  app: apps/tyfo.dev/app
  config: apps/tyfo.dev/config
  tests:
    functional: apps/tyfo.dev/tests/functional
    unit: apps/tyfo.dev/tests/unit
    e2e: apps/tyfo.dev/tests/e2e
  docs: apps/tyfo.dev/docs/implementation
  contracts: apps/tyfo.dev/app/Contracts
  services: apps/tyfo.dev/app/Services
  repositories: apps/tyfo.dev/app/Repositories
  models: apps/tyfo.dev/app/Models
  migrations: apps/tyfo.dev/database/migrations
  seeds: apps/tyfo.dev/database/seeders
  commands: apps/tyfo.dev/commands

# Commandes principales
scripts:
  test: cd apps/tyfo.dev && pnpm run test
  lint: cd apps/tyfo.dev && pnpm run lint
  migrate: cd apps/tyfo.dev && node ace migration:run
  seed: cd apps/tyfo.dev && node ace db:seed
  reset: cd apps/tyfo.dev && node ace db:wipe && node ace migration:run && node ace db:seed
  dev: cd apps/tyfo.dev && node ace serve --watch

# Entités et modèles du domaine
entities:
  - name: User
    fields:
      - name: uuid
        type: string
        primary: true
      - name: fullName
        type: string
      - name: email
        type: string
        unique: true
      - name: password
        type: string
        protected: true
      - name: isArchived
        type: boolean
        default: false
    relations:
      - name: roles
        type: manyToMany
        entity: Role
        through: Attribution
      - name: circles
        type: manyToMany
        entity: Circle
        through: Attribution
      - name: files
        type: oneToMany
        entity: File
  
  - name: Role
    fields:
      - name: uuid
        type: string
        primary: true
      - name: name
        type: string
        unique: true
      - name: description
        type: string
        required: true
    relations:
      - name: users
        type: manyToMany
        entity: User
        through: Attribution

  - name: Circle
    fields:
      - name: uuid
        type: string
        primary: true
      - name: name
        type: string
      - name: description
        type: string
        required: true
      - name: user_id
        type: string
        required: true
      - name: isArchived
        type: boolean
        default: false
    relations:
      - name: users
        type: manyToMany
        entity: User
        through: Attribution
      - name: owner
        type: belongsTo
        entity: User

  - name: Attribution
    fields:
      - name: uuid
        type: string
        primary: true
      - name: user_id
        type: string
        required: true
      - name: role_id
        type: string
        required: true
      - name: circle_id
        type: string
        required: true
    relations:
      - name: user
        type: belongsTo
        entity: User
      - name: role
        type: belongsTo
        entity: Role
      - name: circle
        type: belongsTo
        entity: Circle

  - name: File
    fields:
      - name: uuid
        type: string
        primary: true
      - name: name
        type: string
      - name: path
        type: string
      - name: user_id
        type: string
      - name: isArchived
        type: boolean
        default: false
      - name: metadata
        type: json
    relations:
      - name: user
        type: belongsTo
        entity: User
      - name: versions
        type: oneToMany
        entity: Version

  - name: Version
    fields:
      - name: uuid
        type: string
        primary: true
      - name: file_id
        type: string
      - name: version_number
        type: integer
      - name: content_hash
        type: string
      - name: created_at
        type: datetime
    relations:
      - name: file
        type: belongsTo
        entity: File

  - name: Notification
    fields:
      - name: uuid
        type: string
        primary: true
      - name: user_id
        type: string
      - name: title
        type: string
      - name: message
        type: string
      - name: type
        type: string
      - name: read
        type: boolean
        default: false
      - name: created_at
        type: datetime
    relations:
      - name: user
        type: belongsTo
        entity: User

  - name: EventLog
    fields:
      - name: uuid
        type: string
        primary: true
      - name: user_id
        type: string
      - name: action
        type: string
      - name: entity_type
        type: string
      - name: entity_id
        type: string
      - name: metadata
        type: json
      - name: created_at
        type: datetime
    relations:
      - name: user
        type: belongsTo
        entity: User

# Configuration des tests
testing:
  approach: TDD
  resetDbBeforeEach: true
  useFactories: true
  assertionsPerTest: 1
  preferSupertest: true
  testScenarios:
    - user-creation-flow
    - file-upload-and-versioning
    - role-assignment
    - circle-management
    - full-permission-check

# Conventions de codage
conventions:
  userNameField: fullName
  requireDescriptions:
    - Role
    - Circle
  dateFormat: YYYY-MM-DDTHH:mm:ssZ
  idField: uuid
  defaultPagination: 25
  softDelete: true
  archivableEntities:
    - User
    - Circle
    - File
  fileUploadDirectory: tmp/uploads
  fileStoragePath: storage/app/uploads

# Permissions et sécurité
permissions:
  roles:
    - admin
    - editor
    - viewer
  defaultRole: viewer
  roleHierarchy:
    - admin
    - editor
    - viewer
  roleAssignment: true
  security:
    auditLog: true
    requireAuth: true
    passwordPolicy:
      minLength: 8
      requireNumber: true
      requireSpecial: true

# API endpoints
api:
  auth:
    strategy: jwt
    loginEndpoint: /api/v1/auth/login
    registerEndpoint: /api/v1/auth/register
  endpoints:
    users: /api/v1/users
    roles: /api/v1/roles
    circles: /api/v1/circles
    files: /api/v1/files
    notifications: /api/v1/notifications
  paginationParam: page
  perPageParam: perPage

# Commandes CLI disponibles
cli:
  userCommands:
    - create-user
    - delete-user
    - list-users
    - assign-role
  fileCommands:
    - upload-file
    - list-files
    - delete-file
    - file-history
    - restore-file
  circleCommands:
    - create-circle
    - archive-circle
    - add-user-circle
    - remove-user-circle
    - list-circles

# Intégration continue
ci:
  enabled: true
  provider: GitHub Actions
  testCommand: pnpm run test
  lintCommand: pnpm run lint
  branches:
    main: production
    develop: staging
  triggers:
    - push
    - pullRequest
  notifications:
    success: false
    failure: true

# Configuration du comportement de l'assistant Windsurf
windsurf:
  preferredApproach: TDD
  testFirst: true
  verboseComments: true
  prioritizeUserRequirements: true
  checkForLintErrors: true
  alwaysIncludeTests: true
  suggestDocumentation: true
  apisFirst: true
  uiLast: true
  assistWith:
    - testing
    - api
    - database
    - authentication
    - fileFunctionality
    - userManagement
    - roleManagement
    - circleManagement
    - documentation
  ignoredPatterns:
    - node_modules
    - .git
    - tmp
    - build
    - dist
  maxContextFiles: 50
  maxSearchDepth: 5
  enforceResultPattern: true
  rules:
    - name: "Use Result<T> pattern everywhere"
      description: |
        Toute fonction métier, repository, service ou use case doit retourner un objet Result<T> 
        (succès ou échec explicite) et non pas une valeur brute ni un throw.
        Les exceptions doivent être encapsulées dans Result<T>. 
        Les appels de méthodes doivent être gérés via pattern matching explicite sur Result.
      checks:
        - Vérifier que chaque méthode publique dans `application/use_cases/`, `application/services/` et `infrastructure/repositories/` retourne Result<T>.
        - Refuser les `throw` en dehors des BusinessException dans les couches métier.
        - S'assurer que chaque appelant gère Result avec `if (result.isFailure)` avant d'accéder à [result.value](cci:1://file:///Users/ericmonnier/dev/proto/infinity-test/apps/infinity/app/domain/shared/result.ts:39:2-48:3).
        - Vérifier que les contrôleurs utilisent le pattern : `if (result.isFailure) { throw new BusinessException(...) }`.
        - Interdire l'accès direct à [result.value](cci:1://file:///Users/ericmonnier/dev/proto/infinity-test/apps/infinity/app/domain/shared/result.ts:39:2-48:3) sans vérification préalable de [result.isSuccess](cci:1://file:///Users/ericmonnier/dev/proto/infinity-test/apps/infinity/app/domain/shared/result.ts:25:2-30:3).
      autofix: |
        Si une méthode retourne une valeur brute, la transformer en Result.ok().
        Si une méthode lève une exception métier, l'encapsuler dans Result.fail().
        Corriger "Result.err()" vers "Result.fail()".
        Ajouter les types Result<T> aux signatures manquantes.
        Ajouter les vérifications isFailure/isSuccess manquantes.

    - name: "BusinessException pattern enforcement"
      description: |
        Toutes les exceptions métier doivent hériter de la classe BusinessException.
        Elles doivent fournir automatiquement :
          - un message technique (context) pour les logs
          - un message utilisateur (userMessage) sécurisé
          - une classification (ErrorClassification: USER_SAFE, INTERNAL, SECURITY)
          - un niveau de gravité (ErrorSeverity: low, medium, high, critical)
          - un type de toast (ToastType: error, warning, info)
          - une intégration automatique avec Sentry
        Aucun `throw` direct de `Error` ne doit se faire dans le code métier.
      checks:
        - Vérifier que toutes les classes d'exception héritent de BusinessException.
        - Vérifier que toutes les exceptions définissent : classification, severity, userMessage, toastType, context.
        - Interdire les `throw new Error()` dans les couches `application/`, `domain/` et `infrastructure/`.
        - S'assurer que les exceptions SECURITY n'exposent jamais d'informations sensibles dans userMessage.
        - Vérifier que chaque exception a un nom explicite (ex: EmailAlreadyExistsException, LobbyCreationException).
        - Contrôler que les exceptions sont catchées dans HttpExceptionHandler pour génération automatique de toasts.
      autofix: |
        Si une exception lève `throw new Error()`, la transformer en `throw new <DomainSpecific>Exception()`.
        Ajouter userMessage, classification, severity et toastType si absent.
        Générer automatiquement les messages sécurisés pour les erreurs SECURITY.

    - name: "Toast integration with Sonner"
      description: |
        Toutes les interactions utilisateur doivent fournir un feedback via le système de toast Sonner.
        Les BusinessException génèrent automatiquement des toasts via flash messages.
        Les succès d'opérations importantes doivent déclencher des toasts de confirmation.
      checks:
        - Vérifier que HttpExceptionHandler convertit automatiquement les BusinessException en flash messages.
        - S'assurer que les contrôleurs utilisent `session.flash('success', message)` pour les opérations réussies.
        - Contrôler que le composant ToastHandler est présent dans le layout principal.
        - Vérifier que les toasts utilisent les types appropriés : success, error, warning, info.
        - S'assurer que les messages de toast sont cohérents avec les userMessage des exceptions.
      autofix: |
        Ajouter `session.flash('success', 'Operation completed successfully')` après les opérations critiques.
        Intégrer ToastHandler dans le layout si absent.
        Convertir les console.log d'erreur en toasts appropriés.

    - name: "Domain Driven Design architecture"
      description: |
        Respect strict de l'architecture DDD avec séparation claire des couches :
        - Domain : Entités, Value Objects, Events (aucune dépendance externe)
        - Application : Use Cases, Services applicatifs (orchestration)
        - Infrastructure : Repositories, Adaptateurs techniques
        - Presentation : Contrôleurs, DTOs (transformation des données)
      checks:
        - Vérifier que les entités du `domain/` n'importent aucune dépendance externe.
        - S'assurer que les use cases dans `application/use_cases/` n'accèdent jamais directement aux modèles Lucid.
        - Contrôler que l'injection de dépendances se fait via constructeur dans les use cases.
        - Vérifier que les repositories implémentent des interfaces définies dans `application/repositories/`.
        - S'assurer que les contrôleurs ne contiennent que de la logique de transformation et d'orchestration.
        - Interdire les appels directs aux repositories depuis les contrôleurs (utiliser les use cases).
      autofix: |
        Déplacer la logique métier des contrôleurs vers les use cases.
        Créer des interfaces de repository manquantes dans application/repositories/.
        Ajouter l'injection de dépendances via constructeur si manquante.

    - name: "Security-first error handling"
      description: |
        Gestion sécurisée des erreurs pour éviter l'exposition d'informations sensibles :
        - Prévention des attaques d'énumération d'utilisateurs
        - Messages génériques pour les erreurs sensibles
        - Logs détaillés pour le debugging sans exposition publique
      checks:
        - Vérifier que les erreurs d'authentification utilisent des messages génériques.
        - S'assurer que les erreurs de validation n'exposent pas la structure interne.
        - Contrôler que les erreurs SECURITY ont des userMessage génériques mais des logs détaillés.
        - Vérifier que les stack traces ne sont jamais exposées en production.
        - S'assurer que les erreurs de base de données sont encapsulées dans des BusinessException.
      autofix: |
        Remplacer les messages d'erreur spécifiques par des messages génériques pour les opérations sensibles.
        Ajouter la classification SECURITY aux exceptions sensibles.
        Encapsuler les erreurs techniques dans des BusinessException appropriées.
    
    - name: "Service Testing Strategy"
      description: |
        Les tests doivent se concentrer sur la logique métier des services et use cases.
        Les repositories ne sont pas testés directement car ils ne contiennent que de la persistance.
        Utiliser des DTOs pour découpler les tests des entités domain.
        Privilégier les tests unitaires avec mocks pour les dépendances externes.
      checks:
        - Vérifier que chaque use case a au moins un test unitaire dans `tests/unit/use_cases/`.
        - S'assurer que les tests utilisent des DTOs plutôt que des entités domain directement.
        - Confirmer que les repositories sont mockés dans les tests de use cases.
        - Vérifier que les tests couvrent les cas de succès ET d'échec (Result.ok et Result.fail).
        - S'assurer que les tests vérifient les side effects (événements domain, logs, etc.).
      autofix: |
        Créer automatiquement un fichier de test pour chaque nouveau use case.
        Générer des mocks basiques pour les repositories utilisés.
        Ajouter des tests pour les cas d'erreur manquants.
    
    - name: "DTO and Serialization Pattern"
      description: |
        Utiliser des DTOs (Data Transfer Objects) pour découpler les couches.
        Les DTOs servent d'interface entre les use cases et les entités domain.
        Implémenter des serializers pour convertir entités → DTOs et DTOs → entités.
        Les DTOs doivent être immutables et contenir uniquement des données.
      checks:
        - Vérifier que chaque use case utilise des DTOs en input/output plutôt que des entités.
        - S'assurer que les DTOs sont dans `application/dtos/` avec suffixe `Dto`.
        - Confirmer que les serializers sont dans `application/serializers/` avec suffixe `Serializer`.
        - Vérifier que les DTOs n'ont pas de logique métier (seulement des propriétés).
        - S'assurer que les serializers gèrent les conversions bidirectionnelles.
      autofix: |
        Générer automatiquement des DTOs pour les nouvelles entités.
        Créer des serializers basiques pour les conversions entity ↔ DTO.
        Refactorer les use cases pour utiliser DTOs au lieu d'entités.
    
    - name: "Factory and Test Data Strategy"
      description: |
        Utiliser des factories pour créer des données de test cohérentes et réutilisables.
        Les factories doivent générer des DTOs plutôt que des entités directement.
        Séparer les factories de test des seeders de base de données.
        Permettre la customisation des propriétés via des paramètres optionnels.
      checks:
        - Vérifier que chaque entité a une factory correspondante dans `tests/factories/`.
        - S'assurer que les factories génèrent des DTOs avec suffixe `Factory`.
        - Confirmer que les factories utilisent des données réalistes mais anonymisées.
        - Vérifier que les factories permettent l'override de propriétés spécifiques.
        - S'assurer que les factories sont utilisées dans tous les tests unitaires.
      autofix: |
        Générer automatiquement une factory pour chaque nouvelle entité.
        Créer des factories basiques avec des valeurs par défaut cohérentes.
        Refactorer les tests existants pour utiliser les factories.
    
    - name: "Comprehensive Test Architecture"
      description: |
        Architecture de test en couches avec séparation claire des responsabilités.
        Tests unitaires pour use cases, tests d'intégration pour services, pas de tests pour repositories.
        Utiliser des mocks pour les dépendances externes, des factories pour les données.
        Couvrir les cas de succès, d'échec, et les edge cases.
      checks:
        - Vérifier la structure : tests/unit/, tests/integration/, tests/factories/.
        - S'assurer que les use cases ont des tests unitaires avec mocks.
        - Confirmer que les services ont des tests d'intégration.
        - Vérifier que les tests utilisent factories + DTOs + serializers.
        - S'assurer de la couverture des cas Result.ok et Result.fail.
      autofix: |
        Créer la structure de dossiers de test manquante.
        Générer des tests basiques pour les nouveaux use cases.
        Ajouter des assertions pour les cas d'erreur manquants.
    
    - name: "Factory and Faker Strategy"
      description: |
        Les factories doivent être complétées par des fakers qui héritent des classes de base.
        Les fakers remplacent l’usage de sinon pour la génération de données réalistes.
        Chaque faker doit générer des données cohérentes, réalistes et anonymisées.
        Les fakers doivent être fortement typés et découplés de la logique métier.
      checks:
        - Vérifier qu'aucun test n'utilise sinon (préférer jest.fn() ou des mocks internes).
        - S'assurer que chaque entité/DTO a un faker correspondant dans `tests/fakers/`.
        - Confirmer que les fakers héritent d'une classe de base (BaseFaker).
        - Vérifier que les fakers permettent l'override de propriétés spécifiques.
        - S'assurer que les fakers sont utilisés dans toutes les factories.
      autofix: |
        Supprimer les imports de sinon et remplacer par jest.fn().
        Générer automatiquement un BaseFaker pour chaque entité.
        Créer les fakers hérités pour les entités manquantes.
        Refactorer les factories pour consommer les fakers.
    
    - name: "Hexagonal Architecture Enforcement"
      description: |
        Respect strict du pattern Ports & Adapters :
        - Les use cases ne dépendent que d’interfaces (ports).
        - Les implémentations concrètes (adapters : S3, Mailer, etc.) résident dans infrastructure/.
        - L’injection de dépendances se fait uniquement via constructeur.
      checks:
        - Vérifier que les use cases n’importent pas directement d’implémentations techniques.
        - S'assurer que toutes les dépendances externes passent par des interfaces dans `application/ports/`.
        - Contrôler que l'infrastructure implémente les ports définis.
      autofix: |
        Générer automatiquement des interfaces ports pour les dépendances externes.
        Déplacer les appels techniques dans infrastructure/.
        Injecter les adapters via constructeur dans les use cases.
   
    - name: "Contract Testing Strategy"
      description: |
        Les contrats entre couches doivent être validés par des tests de contrat.
        Les tests de contrat garantissent la compatibilité entre DTOs, serializers et API endpoints.
      checks:
        - Vérifier que chaque endpoint API a un test de contrat dans `tests/contract/`.
        - S'assurer que les serializers respectent les schémas DTO.
        - Confirmer que les changements de schéma cassants déclenchent une erreur de test.
      autofix: |
        Générer un test de contrat pour chaque nouvel endpoint.
        Ajouter un validateur de schéma JSON (Zod ou Joi) dans les tests.
   
    - name: "Mutation Testing Strategy"
      description: |
        Utiliser des tests de mutation (ex: StrykerJS) pour valider la robustesse des tests.
        Les tests doivent échouer si une mutation est introduite dans le code.
      checks:
        - Vérifier que le pipeline CI exécute les mutation tests au moins sur la couche application.
        - S'assurer que le seuil de mutation coverage est > 80%.
      autofix: |
        Ajouter StrykerJS dans la configuration du projet.
        Générer une configuration de mutation par défaut.
    
    - name: "Test Coverage Enforcement"
      description: |
        Les tests doivent couvrir au moins 80% du code de la couche application et domain.
        Les contrôleurs et infrastructure peuvent avoir une couverture plus faible.
      checks:
        - Vérifier que le coverage global est >= 80%.
        - Vérifier que la couche application/ est >= 90%.
        - Vérifier que la couche domain/ est >= 90%.
      autofix: |
        Ajouter la vérification du coverage dans la CI.
        Générer un rapport coverage HTML à chaque run.
    
    - name: "Dependency Injection Enforcement"
      description: |
        Toutes les dépendances doivent être injectées explicitement (via constructeur ou factory).
        Aucun service ou repository ne doit être instancié directement dans un use case ou contrôleur.
        Les dépendances doivent être définies sous forme d’interfaces dans `application/ports/`
        et fournies via injection par l’infrastructure.
      checks:
        - Vérifier que les use cases n’appellent pas `new` pour instancier une dépendance.
        - S’assurer que les contrôleurs n’instancient pas de services/repositories directement.
        - Contrôler que l’injection se fait toujours via constructeur (pas via propriété statique).
        - Vérifier que les adapters dans `infrastructure/` implémentent les interfaces définies dans `application/ports/`.
        - Interdire l’utilisation d’un container global ou singleton pour résoudre les dépendances.
      autofix: |
        Déplacer les instanciations de dépendances vers des factories ou des modules d’injection.
        Ajouter les interfaces manquantes dans `application/ports/`.
        Injecter les dépendances via constructeur dans les use cases et services.
    
    - name: "UI Library Consistency"
      description: |
        Les composants dans `packages/ui` constituent une librairie réutilisable.
        Ils doivent être découplés de la logique métier et testés isolément.
        Les composants doivent être documentés et exposés dans `apps/docs` (Storybook).
      checks:
        - Vérifier que `packages/ui` ne contient aucune dépendance vers `apps/`.
        - S'assurer que chaque nouveau composant est accompagné d'une story dans `apps/docs`.
        - Vérifier que les composants UI sont testés avec React Testing Library.
        - Confirmer que chaque composant a des props typées avec TypeScript.
      autofix: |
        Créer automatiquement un fichier de story pour chaque composant.
        Ajouter des tests unitaires de rendu basiques si absents.
        Bloquer l’import de code applicatif dans `packages/ui`.

    - name: "Storybook Documentation Enforcement"
      description: |
        Storybook (`apps/docs`) sert de documentation vivante pour les composants UI.
        Il doit être mis à jour à chaque ajout ou modification d’un composant.
      checks:
        - Vérifier que chaque composant de `packages/ui` a une story correspondante.
        - S'assurer que les stories couvrent tous les états/variantes des composants.
        - Contrôler que Storybook build sans erreur dans la CI.
      autofix: |
        Générer une story minimale lors de la création d’un nouveau composant.
        Ajouter automatiquement les variantes manquantes détectées.
        Lancer `pnpm storybook:build` en CI pour détecter les incohérences.

    - name: "Visual Regression Testing"
      description: |
        Les composants UI doivent être validés par des tests de régression visuelle.
        Les différences de rendu doivent être détectées automatiquement lors des PR.
      checks:
        - Vérifier que la CI exécute les tests visuels sur `apps/docs`.
        - S'assurer que les PR échouent en cas de différence non approuvée.
      autofix: |
        Ajouter Chromatic ou Playwright dans la CI.
        Générer automatiquement des snapshots visuels pour les nouveaux composants.

    - name: "Domain Factory Rule"
      description: |
        Les entités complexes doivent être créées via des factories métier dans `domain/factories/`.
        Les factories métier encapsulent la logique de création et garantissent la validité métier.
        Les repositories utilisent les factories métier pour hydrater les entités depuis la base.
      checks:
        - Vérifier que les entités ne sont pas instanciées directement dans les use cases.
        - S'assurer que les repositories appellent une factory métier pour reconstruire une entité.
        - Contrôler que les factories métier vivent uniquement dans `domain/factories/`.
      autofix: |
        Déplacer la logique de création d'entité vers une factory métier.
        Ajouter une factory manquante dans `domain/factories/`.

    - name: "Test/Seed Factory Rule"
      description: |
        Les factories de test/seed (DTO builders) sont réservées aux tests et à l’initialisation de données.
        Elles ne doivent jamais être utilisées dans le code applicatif (domain, application, infrastructure).
      checks:
        - Vérifier que les factories de test/seed résident uniquement dans `tests/factories/` ou `database/factories/`.
        - Interdire leur import dans `app/`.
        - Confirmer que les seeders utilisent ces factories au lieu d’objets bruts.
      autofix: |
        Déplacer les factories de test/seed en dehors du dossier `app/`.
        Supprimer les imports interdits dans le code applicatif.

# ============================================================================
# RÈGLES SPÉCIFIQUES AU PROJET INFINITY
# À COPIER-COLLER À LA FIN DU FICHIER .windsurfrules
# ============================================================================

# Projet Infinity - Configuration
infinity_project:
  name: Infinity
  description: Plateforme de jeux multijoueurs en temps réel avec lobbies
  root: apps/infinity
  architecture: DDD (Domain-Driven Design)
  frontend: React + Inertia.js
  backend: AdonisJS
  realtime: Transmit (WebSocket)

# Règles Infinity spécifiques
infinity_rules:
  
  # 1. STRUCTURE DES ROUTES
  - name: "Infinity Routes Structure"
    description: |
      Un seul fichier de routes actif pour toute l'application.
      Aucun fichier de routes dans app/routes/.
      Convention REST stricte pour les méthodes de contrôleur.
    location: apps/infinity/start/routes.ts
    forbidden:
      - apps/infinity/app/routes/web.ts
      - apps/infinity/app/routes/api_routes.ts
      - apps/infinity/app/routes/complete_routes.ts
    checks:
      - Vérifier qu'aucun fichier n'existe dans apps/infinity/app/routes/
      - S'assurer que toutes les routes sont dans start/routes.ts
      - Vérifier que les méthodes suivent la convention REST (index, show, store, update, destroy)
      - Confirmer que GET/POST sont séparés (showCreateForm vs store)
    autofix: |
      Déplacer automatiquement les routes vers start/routes.ts
      Archiver les anciens fichiers dans _archive/
      Corriger les noms de méthodes non-conventionnels
  
  # 2. STRUCTURE DES PAGES INERTIA
  - name: "Infinity Pages Organization"
    description: |
      Pages organisées par domaine DDD dans inertia/pages/.
      Convention stricte : index.tsx (liste), show.tsx (détail), create.tsx (création).
      Aucune page de domaine à la racine (sauf home/welcome).
    structure: |
      inertia/pages/
      ├── auth/              (Domaine IAM)
      │   ├── login.tsx
      │   └── register.tsx
      ├── lobbies/          (Domaine Lobby)
      │   ├── index.tsx     → Liste
      │   ├── create.tsx    → Création
      │   ├── show.tsx      → Détail
      │   └── join.tsx      → Action spécifique
      ├── games/            (Domaine Game Engine)
      │   └── show.tsx
      ├── dev/              (Outils développement)
      ├── errors/           (Pages d'erreur)
      ├── home.tsx          (Pages publiques)
      └── welcome.tsx
    forbidden:
      - Pages de domaine à la racine (create-lobby.tsx, lobby.tsx, game.tsx)
      - Dossiers vides (pages/lobbies/ vide)
      - Noms avec tirets ou underscores pour les domaines
      - Pages dupliquées
    checks:
      - Vérifier qu'aucune page {domaine}* n'est à la racine
      - S'assurer que chaque dossier contient au moins 1 fichier
      - Confirmer la convention de nommage (index, show, create, edit)
      - Vérifier l'absence de doublons
    autofix: |
      Déplacer automatiquement les pages vers leur dossier de domaine
      Renommer selon la convention (create-lobby.tsx → lobbies/create.tsx)
      Supprimer les dossiers vides
      Mettre à jour les imports relatifs après déplacement
  
  # 3. STRUCTURE DES COMPOSANTS
  - name: "Infinity Components Separation"
    description: |
      Séparation stricte entre composants réutilisables et spécifiques.
      Composants réutilisables dans packages/ui/.
      Composants spécifiques Infinity dans apps/infinity/inertia/components/.
    packages_ui: |
      Composants RÉUTILISABLES (multi-apps)
      - Pas de logique métier spécifique
      - Props génériques
      - Documentés dans Storybook
      - Exemples: header.tsx, footer.tsx, lobby-card.tsx
    apps_components: |
      Composants SPÉCIFIQUES (app Infinity uniquement)
      - Logique métier spécifique
      - Hooks/contexts applicatifs
      - Services applicatifs
      - Exemples: layout.tsx, HeaderWrapper.tsx, GameLobby.tsx
    checks:
      - Vérifier que packages/ui n'importe rien de apps/
      - S'assurer qu'il n'y a pas de doublons
      - Confirmer que chaque composant UI a une story Storybook
      - Vérifier que les composants spécifiques ne sont pas dans packages/ui
    autofix: |
      Bloquer automatiquement les imports de apps/ dans packages/ui/
      Créer une story Storybook pour les nouveaux composants UI
      Déplacer les composants réutilisables vers packages/ui/
  
  # 4. CONTRÔLEURS INERTIA
  - name: "Infinity Controllers Render Paths"
    description: |
      Les contrôleurs doivent rendre les bonnes pages avec chemins relatifs corrects.
      Format: inertia.render('domain/action') relatif à inertia/pages/
    convention:
      - "inertia.render('lobbies/index')   // pages/lobbies/index.tsx"
      - "inertia.render('lobbies/create')  // pages/lobbies/create.tsx"
      - "inertia.render('games/show')      // pages/games/show.tsx"
    checks:
      - Vérifier que chaque inertia.render() pointe vers un fichier existant
      - S'assurer que les chemins sont relatifs à pages/
      - Confirmer l'absence de chemins obsolètes
      - Vérifier que les props correspondent aux interfaces TypeScript
    autofix: |
      Mettre à jour automatiquement les chemins après migration
      Corriger les chemins obsolètes (lobbies → lobbies/index)
      Ajouter les props manquantes dans les interfaces
  
  # 5. REPOSITORIES DDD
  - name: "Infinity Repository Completeness"
    description: |
      Tous les repositories doivent implémenter l'interface base complète.
      Méthodes obligatoires: save, findById, delete, exists.
      Retours en Result<T> uniquement.
    base_methods:
      - "save(entity: T): Promise<Result<T>>"
      - "findById(id: string): Promise<Result<T | null>>"
      - "delete(id: string): Promise<Result<void>>"
      - "exists(id: string): Promise<boolean>"
    checks:
      - Vérifier que tous les repositories implémentent toutes les méthodes
      - S'assurer que les retours sont Result<T> et non des valeurs brutes
      - Confirmer l'enregistrement dans app_provider.ts (IoC container)
    autofix: |
      Ajouter automatiquement les méthodes manquantes
      Transformer les retours bruts en Result.ok()/Result.fail()
      Enregistrer dans le container IoC si absent
  
  # 6. COMMANDS ET HANDLERS DDD
  - name: "Infinity Commands Consistency"
    description: |
      Les commandes et handlers doivent être cohérents.
      Nombre d'arguments correct, types corrects, Result<T> en retour.
    checks:
      - Vérifier la cohérence des arguments du constructeur
      - S'assurer que les types sont corrects
      - Confirmer l'utilisation d'EventBus pour les événements
      - Vérifier que le handler retourne Result<T>
    autofix: |
      Corriger automatiquement le nombre d'arguments
      Ajouter les imports manquants
      Transformer les retours en Result<T>
  
  # 7. ÉVÉNEMENTS DOMAIN
  - name: "Infinity Domain Events Naming"
    description: |
      Convention stricte pour les noms d'événements domain.
      Format obligatoire: {domain}.{entity}.{action}
    naming_convention:
      format: "{domain}.{entity}.{action}"
      examples:
        - "iam.user.logged.in"
        - "lobby.lobby.created"
        - "game.game.started"
    registry_location: "domains/{domain}/infrastructure/events/{domain}.event_registry.ts"
    checks:
      - Vérifier la convention de nommage des événements
      - S'assurer que les registries sont importés dans module_event_provider.ts
      - Confirmer que domainName correspond au préfixe des événements
    autofix: |
      Renommer automatiquement les événements non-conformes
      Corriger le domainName dans les registries
      Ajouter les registries manquants dans module_event_provider.ts
  
  # 8. AUTHENTIFICATION SÉCURISÉE
  - name: "Infinity Auth Security"
    description: |
      Gestion sécurisée de l'authentification et des mots de passe.
      Pas de double hash, types corrects pour auth.login(), sharedData obligatoire.
    password_rules:
      - "Ne JAMAIS hasher dans le seeder (laisser le hook @beforeSave())"
      - "Passer le password en clair au seeder"
    auth_login_rules:
      - "auth.login() attend un modèle Lucid, pas une entité DDD"
      - "Récupérer le modèle Lucid après authentification DDD réussie"
    shared_data_rules:
      - "Toujours partager user via inertia sharedData"
      - "Ne pas passer user en prop si déjà dans sharedData"
    checks:
      - Vérifier que les seeders passent des passwords en clair
      - S'assurer que auth.login() reçoit un modèle Lucid
      - Confirmer que user est dans sharedData (config/inertia.ts)
    autofix: |
      Supprimer hash.make() dans les seeders
      Ajouter la récupération du modèle Lucid après auth DDD
      Ajouter user dans sharedData si absent
  
  # 9. DOCUMENTATION OBLIGATOIRE
  - name: "Infinity Documentation Requirement"
    description: |
      Chaque changement majeur doit être documenté dans docs/.
      Tests obligatoires pour les nouvelles fonctionnalités.
    required_docs:
      migrations: "docs/migrations/{FEATURE}_MIGRATION.md"
      corrections: "docs/corrections/{PROBLEM}_FIX.md"
      architecture: "docs/architecture/{CONCEPT}_STRATEGY.md"
    tests:
      unit: "tests/unit/**/*.spec.ts"
      integration: "tests/integration/**/*.spec.ts"
    checks:
      - Vérifier qu'un fichier .md existe pour chaque changement majeur
      - S'assurer que les tests existent pour les nouvelles fonctionnalités
      - Confirmer que la documentation est à jour
    autofix: |
      Créer automatiquement un template de documentation
      Générer des tests de base pour les nouvelles fonctionnalités
  
  # 10. CHECKLIST DE VALIDATION
  - name: "Infinity Validation Checklist"
    description: |
      Checklist obligatoire avant chaque commit important.
      Valide la structure, les conventions, et les tests.
    after_route_changes:
      - "Toutes les routes dans /start/routes.ts"
      - "Aucun fichier dans app/routes/"
      - "Tous les contrôleurs ont les méthodes référencées"
      - "node ace list:routes affiche toutes les routes"
    after_page_changes:
      - "Toutes les pages dans leurs dossiers de domaine"
      - "Aucun dossier vide"
      - "Tous les imports relatifs corrects"
      - "Tous les inertia.render() à jour"
    after_component_changes:
      - "Composants réutilisables dans packages/ui/"
      - "Composants spécifiques dans apps/infinity/components/"
      - "Pas de doublons"
      - "Story Storybook créée (si packages/ui)"
    after_ddd_changes:
      - "Repositories implémentent toutes les méthodes"
      - "Repositories enregistrés dans app_provider.ts"
      - "Commands ont le bon nombre d'arguments"
      - "Handlers retournent Result<T>"
      - "Événements suivent la convention"

# Erreurs fréquentes à éviter (Infinity)
infinity_forbidden_patterns:
  routes:
    - "Créer des fichiers dans app/routes/"
    - "Utiliser des méthodes non-REST (.create() au lieu de .store())"
  pages:
    - "Pages de domaine à la racine"
    - "Dossiers vides"
    - "Noms avec tirets (create-lobby.tsx)"
  components:
    - "Composants réutilisables dans apps/"
    - "Imports de apps/ dans packages/ui/"
  repositories:
    - "Repository sans méthode exists()"
    - "Retours directs sans Result<T>"
  auth:
    - "Hasher le password dans le seeder"
    - "Passer une entité DDD à auth.login()"
  events:
    - "Noms d'événements non-conventionnés"
    - "Registry non importé dans module_event_provider"

# Commandes de validation (Infinity)
infinity_validation_commands:
  routes: "node ace list:routes"
  pages_structure: "find apps/infinity/inertia/pages -type d -empty"
  obsolete_routes: "ls apps/infinity/app/routes/*.ts 2>/dev/null"
  component_imports: "grep -r 'from.*apps/' packages/ui/src/components/"
  tests: "node ace test"
