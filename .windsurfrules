# Tyfo.dev Project Windsurf Rules
# Configuration complète pour l'assistant Windsurf AI

# Information générale sur le projet
project:
  name: Tyfo.dev
  description: Plateforme collaborative de gestion de fichiers avec gestion avancée des utilisateurs, rôles et cercles
  repository: https://github.com/tungdil213/tyfo.dev
  root: apps/tyfo.dev
  structure: monorepo
  packageManager: pnpm
  containerization: Docker

# Architecture technique
architecture:
  backend: AdonisJS
  frontend: React
  styling: TailwindCSS
  viewEngine: InertiaJS
  database: PostgreSQL
  authentication: JWT
  testing: Jest
  apiVersion: v1
  apiBasePath: /api/v1

# Répertoires importants
directories:
  app: apps/tyfo.dev/app
  config: apps/tyfo.dev/config
  tests:
    functional: apps/tyfo.dev/tests/functional
    unit: apps/tyfo.dev/tests/unit
    e2e: apps/tyfo.dev/tests/e2e
  docs: apps/tyfo.dev/docs/implementation
  contracts: apps/tyfo.dev/app/Contracts
  services: apps/tyfo.dev/app/Services
  repositories: apps/tyfo.dev/app/Repositories
  models: apps/tyfo.dev/app/Models
  migrations: apps/tyfo.dev/database/migrations
  seeds: apps/tyfo.dev/database/seeders
  commands: apps/tyfo.dev/commands

# Commandes principales
scripts:
  test: cd apps/tyfo.dev && pnpm run test
  lint: cd apps/tyfo.dev && pnpm run lint
  migrate: cd apps/tyfo.dev && node ace migration:run
  seed: cd apps/tyfo.dev && node ace db:seed
  reset: cd apps/tyfo.dev && node ace db:wipe && node ace migration:run && node ace db:seed
  dev: cd apps/tyfo.dev && node ace serve --watch

# Entités et modèles du domaine
entities:
  - name: User
    fields:
      - name: uuid
        type: string
        primary: true
      - name: fullName
        type: string
      - name: email
        type: string
        unique: true
      - name: password
        type: string
        protected: true
      - name: isArchived
        type: boolean
        default: false
    relations:
      - name: roles
        type: manyToMany
        entity: Role
        through: Attribution
      - name: circles
        type: manyToMany
        entity: Circle
        through: Attribution
      - name: files
        type: oneToMany
        entity: File
  
  - name: Role
    fields:
      - name: uuid
        type: string
        primary: true
      - name: name
        type: string
        unique: true
      - name: description
        type: string
        required: true
    relations:
      - name: users
        type: manyToMany
        entity: User
        through: Attribution

  - name: Circle
    fields:
      - name: uuid
        type: string
        primary: true
      - name: name
        type: string
      - name: description
        type: string
        required: true
      - name: user_id
        type: string
        required: true
      - name: isArchived
        type: boolean
        default: false
    relations:
      - name: users
        type: manyToMany
        entity: User
        through: Attribution
      - name: owner
        type: belongsTo
        entity: User

  - name: Attribution
    fields:
      - name: uuid
        type: string
        primary: true
      - name: user_id
        type: string
        required: true
      - name: role_id
        type: string
        required: true
      - name: circle_id
        type: string
        required: true
    relations:
      - name: user
        type: belongsTo
        entity: User
      - name: role
        type: belongsTo
        entity: Role
      - name: circle
        type: belongsTo
        entity: Circle

  - name: File
    fields:
      - name: uuid
        type: string
        primary: true
      - name: name
        type: string
      - name: path
        type: string
      - name: user_id
        type: string
      - name: isArchived
        type: boolean
        default: false
      - name: metadata
        type: json
    relations:
      - name: user
        type: belongsTo
        entity: User
      - name: versions
        type: oneToMany
        entity: Version

  - name: Version
    fields:
      - name: uuid
        type: string
        primary: true
      - name: file_id
        type: string
      - name: version_number
        type: integer
      - name: content_hash
        type: string
      - name: created_at
        type: datetime
    relations:
      - name: file
        type: belongsTo
        entity: File

  - name: Notification
    fields:
      - name: uuid
        type: string
        primary: true
      - name: user_id
        type: string
      - name: title
        type: string
      - name: message
        type: string
      - name: type
        type: string
      - name: read
        type: boolean
        default: false
      - name: created_at
        type: datetime
    relations:
      - name: user
        type: belongsTo
        entity: User

  - name: EventLog
    fields:
      - name: uuid
        type: string
        primary: true
      - name: user_id
        type: string
      - name: action
        type: string
      - name: entity_type
        type: string
      - name: entity_id
        type: string
      - name: metadata
        type: json
      - name: created_at
        type: datetime
    relations:
      - name: user
        type: belongsTo
        entity: User

# Configuration des tests
testing:
  approach: TDD
  resetDbBeforeEach: true
  useFactories: true
  assertionsPerTest: 1
  preferSupertest: true
  testScenarios:
    - user-creation-flow
    - file-upload-and-versioning
    - role-assignment
    - circle-management
    - full-permission-check

# Conventions de codage
conventions:
  userNameField: fullName
  requireDescriptions:
    - Role
    - Circle
  dateFormat: YYYY-MM-DDTHH:mm:ssZ
  idField: uuid
  defaultPagination: 25
  softDelete: true
  archivableEntities:
    - User
    - Circle
    - File
  fileUploadDirectory: tmp/uploads
  fileStoragePath: storage/app/uploads

# Permissions et sécurité
permissions:
  roles:
    - admin
    - editor
    - viewer
  defaultRole: viewer
  roleHierarchy:
    - admin
    - editor
    - viewer
  roleAssignment: true
  security:
    auditLog: true
    requireAuth: true
    passwordPolicy:
      minLength: 8
      requireNumber: true
      requireSpecial: true

# API endpoints
api:
  auth:
    strategy: jwt
    loginEndpoint: /api/v1/auth/login
    registerEndpoint: /api/v1/auth/register
  endpoints:
    users: /api/v1/users
    roles: /api/v1/roles
    circles: /api/v1/circles
    files: /api/v1/files
    notifications: /api/v1/notifications
  paginationParam: page
  perPageParam: perPage

# Commandes CLI disponibles
cli:
  userCommands:
    - create-user
    - delete-user
    - list-users
    - assign-role
  fileCommands:
    - upload-file
    - list-files
    - delete-file
    - file-history
    - restore-file
  circleCommands:
    - create-circle
    - archive-circle
    - add-user-circle
    - remove-user-circle
    - list-circles

# Intégration continue
ci:
  enabled: true
  provider: GitHub Actions
  testCommand: pnpm run test
  lintCommand: pnpm run lint
  branches:
    main: production
    develop: staging
  triggers:
    - push
    - pullRequest
  notifications:
    success: false
    failure: true

# Configuration du comportement de l'assistant Windsurf
windsurf:
  preferredApproach: TDD
  testFirst: true
  verboseComments: true
  prioritizeUserRequirements: true
  checkForLintErrors: true
  alwaysIncludeTests: true
  suggestDocumentation: true
  apisFirst: true
  uiLast: true
  assistWith:
    - testing
    - api
    - database
    - authentication
    - fileFunctionality
    - userManagement
    - roleManagement
    - circleManagement
    - documentation
  ignoredPatterns:
    - node_modules
    - .git
    - tmp
    - build
    - dist
  maxContextFiles: 50
  maxSearchDepth: 5
  enforceResultPattern: true
  rules:
    - name: "Use Result<T> pattern everywhere"
      description: |
        Toute fonction métier, repository, service ou use case doit retourner un objet Result<T> 
        (succès ou échec explicite) et non pas une valeur brute ni un throw.
        Les exceptions doivent être encapsulées dans Result<T>. 
        Les appels de méthodes doivent être gérés via pattern matching explicite sur Result.
      checks:
        - Vérifier que chaque méthode publique dans `application/use_cases/`, `application/services/` et `infrastructure/repositories/` retourne Result<T>.
        - Refuser les `throw` en dehors des BusinessException dans les couches métier.
        - S'assurer que chaque appelant gère Result avec `if (result.isFailure)` avant d'accéder à [result.value](cci:1://file:///Users/ericmonnier/dev/proto/infinity-test/apps/infinity/app/domain/shared/result.ts:39:2-48:3).
        - Vérifier que les contrôleurs utilisent le pattern : `if (result.isFailure) { throw new BusinessException(...) }`.
        - Interdire l'accès direct à [result.value](cci:1://file:///Users/ericmonnier/dev/proto/infinity-test/apps/infinity/app/domain/shared/result.ts:39:2-48:3) sans vérification préalable de [result.isSuccess](cci:1://file:///Users/ericmonnier/dev/proto/infinity-test/apps/infinity/app/domain/shared/result.ts:25:2-30:3).
      autofix: |
        Si une méthode retourne une valeur brute, la transformer en Result.ok().
        Si une méthode lève une exception métier, l'encapsuler dans Result.fail().
        Corriger "Result.err()" vers "Result.fail()".
        Ajouter les types Result<T> aux signatures manquantes.
        Ajouter les vérifications isFailure/isSuccess manquantes.

    - name: "BusinessException pattern enforcement"
      description: |
        Toutes les exceptions métier doivent hériter de la classe BusinessException.
        Elles doivent fournir automatiquement :
          - un message technique (context) pour les logs
          - un message utilisateur (userMessage) sécurisé
          - une classification (ErrorClassification: USER_SAFE, INTERNAL, SECURITY)
          - un niveau de gravité (ErrorSeverity: low, medium, high, critical)
          - un type de toast (ToastType: error, warning, info)
          - une intégration automatique avec Sentry
        Aucun `throw` direct de `Error` ne doit se faire dans le code métier.
      checks:
        - Vérifier que toutes les classes d'exception héritent de BusinessException.
        - Vérifier que toutes les exceptions définissent : classification, severity, userMessage, toastType, context.
        - Interdire les `throw new Error()` dans les couches `application/`, `domain/` et `infrastructure/`.
        - S'assurer que les exceptions SECURITY n'exposent jamais d'informations sensibles dans userMessage.
        - Vérifier que chaque exception a un nom explicite (ex: EmailAlreadyExistsException, LobbyCreationException).
        - Contrôler que les exceptions sont catchées dans HttpExceptionHandler pour génération automatique de toasts.
      autofix: |
        Si une exception lève `throw new Error()`, la transformer en `throw new <DomainSpecific>Exception()`.
        Ajouter userMessage, classification, severity et toastType si absent.
        Générer automatiquement les messages sécurisés pour les erreurs SECURITY.

    - name: "Toast integration with Sonner"
      description: |
        Toutes les interactions utilisateur doivent fournir un feedback via le système de toast Sonner.
        Les BusinessException génèrent automatiquement des toasts via flash messages.
        Les succès d'opérations importantes doivent déclencher des toasts de confirmation.
      checks:
        - Vérifier que HttpExceptionHandler convertit automatiquement les BusinessException en flash messages.
        - S'assurer que les contrôleurs utilisent `session.flash('success', message)` pour les opérations réussies.
        - Contrôler que le composant ToastHandler est présent dans le layout principal.
        - Vérifier que les toasts utilisent les types appropriés : success, error, warning, info.
        - S'assurer que les messages de toast sont cohérents avec les userMessage des exceptions.
      autofix: |
        Ajouter `session.flash('success', 'Operation completed successfully')` après les opérations critiques.
        Intégrer ToastHandler dans le layout si absent.
        Convertir les console.log d'erreur en toasts appropriés.

    - name: "Domain Driven Design architecture"
      description: |
        Respect strict de l'architecture DDD avec séparation claire des couches :
        - Domain : Entités, Value Objects, Events (aucune dépendance externe)
        - Application : Use Cases, Services applicatifs (orchestration)
        - Infrastructure : Repositories, Adaptateurs techniques
        - Presentation : Contrôleurs, DTOs (transformation des données)
      checks:
        - Vérifier que les entités du `domain/` n'importent aucune dépendance externe.
        - S'assurer que les use cases dans `application/use_cases/` n'accèdent jamais directement aux modèles Lucid.
        - Contrôler que l'injection de dépendances se fait via constructeur dans les use cases.
        - Vérifier que les repositories implémentent des interfaces définies dans `application/repositories/`.
        - S'assurer que les contrôleurs ne contiennent que de la logique de transformation et d'orchestration.
        - Interdire les appels directs aux repositories depuis les contrôleurs (utiliser les use cases).
      autofix: |
        Déplacer la logique métier des contrôleurs vers les use cases.
        Créer des interfaces de repository manquantes dans application/repositories/.
        Ajouter l'injection de dépendances via constructeur si manquante.

    - name: "Security-first error handling"
      description: |
        Gestion sécurisée des erreurs pour éviter l'exposition d'informations sensibles :
        - Prévention des attaques d'énumération d'utilisateurs
        - Messages génériques pour les erreurs sensibles
        - Logs détaillés pour le debugging sans exposition publique
      checks:
        - Vérifier que les erreurs d'authentification utilisent des messages génériques.
        - S'assurer que les erreurs de validation n'exposent pas la structure interne.
        - Contrôler que les erreurs SECURITY ont des userMessage génériques mais des logs détaillés.
        - Vérifier que les stack traces ne sont jamais exposées en production.
        - S'assurer que les erreurs de base de données sont encapsulées dans des BusinessException.
      autofix: |
        Remplacer les messages d'erreur spécifiques par des messages génériques pour les opérations sensibles.
        Ajouter la classification SECURITY aux exceptions sensibles.
        Encapsuler les erreurs techniques dans des BusinessException appropriées.
    - name: "Service Testing Strategy"
      description: |
        Les tests doivent se concentrer sur la logique métier des services et use cases.
        Les repositories ne sont pas testés directement car ils ne contiennent que de la persistance.
        Utiliser des DTOs pour découpler les tests des entités domain.
        Privilégier les tests unitaires avec mocks pour les dépendances externes.
      checks:
        - Vérifier que chaque use case a au moins un test unitaire dans `tests/unit/use_cases/`.
        - S'assurer que les tests utilisent des DTOs plutôt que des entités domain directement.
        - Confirmer que les repositories sont mockés dans les tests de use cases.
        - Vérifier que les tests couvrent les cas de succès ET d'échec (Result.ok et Result.fail).
        - S'assurer que les tests vérifient les side effects (événements domain, logs, etc.).
      autofix: |
        Créer automatiquement un fichier de test pour chaque nouveau use case.
        Générer des mocks basiques pour les repositories utilisés.
        Ajouter des tests pour les cas d'erreur manquants.
    - name: "DTO and Serialization Pattern"
      description: |
        Utiliser des DTOs (Data Transfer Objects) pour découpler les couches.
        Les DTOs servent d'interface entre les use cases et les entités domain.
        Implémenter des serializers pour convertir entités → DTOs et DTOs → entités.
        Les DTOs doivent être immutables et contenir uniquement des données.
      checks:
        - Vérifier que chaque use case utilise des DTOs en input/output plutôt que des entités.
        - S'assurer que les DTOs sont dans `application/dtos/` avec suffixe `Dto`.
        - Confirmer que les serializers sont dans `application/serializers/` avec suffixe `Serializer`.
        - Vérifier que les DTOs n'ont pas de logique métier (seulement des propriétés).
        - S'assurer que les serializers gèrent les conversions bidirectionnelles.
      autofix: |
        Générer automatiquement des DTOs pour les nouvelles entités.
        Créer des serializers basiques pour les conversions entity ↔ DTO.
        Refactorer les use cases pour utiliser DTOs au lieu d'entités.
    - name: "Factory and Test Data Strategy"
      description: |
        Utiliser des factories pour créer des données de test cohérentes et réutilisables.
        Les factories doivent générer des DTOs plutôt que des entités directement.
        Séparer les factories de test des seeders de base de données.
        Permettre la customisation des propriétés via des paramètres optionnels.
      checks:
        - Vérifier que chaque entité a une factory correspondante dans `tests/factories/`.
        - S'assurer que les factories génèrent des DTOs avec suffixe `Factory`.
        - Confirmer que les factories utilisent des données réalistes mais anonymisées.
        - Vérifier que les factories permettent l'override de propriétés spécifiques.
        - S'assurer que les factories sont utilisées dans tous les tests unitaires.
      autofix: |
        Générer automatiquement une factory pour chaque nouvelle entité.
        Créer des factories basiques avec des valeurs par défaut cohérentes.
        Refactorer les tests existants pour utiliser les factories.
    - name: "Comprehensive Test Architecture"
      description: |
        Architecture de test en couches avec séparation claire des responsabilités.
        Tests unitaires pour use cases, tests d'intégration pour services, pas de tests pour repositories.
        Utiliser des mocks pour les dépendances externes, des factories pour les données.
        Couvrir les cas de succès, d'échec, et les edge cases.
      checks:
        - Vérifier la structure : tests/unit/, tests/integration/, tests/factories/.
        - S'assurer que les use cases ont des tests unitaires avec mocks.
        - Confirmer que les services ont des tests d'intégration.
        - Vérifier que les tests utilisent factories + DTOs + serializers.
        - S'assurer de la couverture des cas Result.ok et Result.fail.
      autofix: |
        Créer la structure de dossiers de test manquante.
        Générer des tests basiques pour les nouveaux use cases.
        Ajouter des assertions pour les cas d'erreur manquants.